<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>flippy: Simplest Monte Carlo simulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">flippy
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_demo_biconcave_shapes__m_c__readme.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Simplest Monte Carlo simulation </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="demo_biconcave_shapes_MC"></a></p>
<h1><a class="anchor" id="autotoc_md0"></a>
Simplest Monte Carlo simulation</h1>
<p >This folder contains the simplest monte carlo simulation that I could imagine building, which still generates visual results, that are non-trivial.</p>
<ul>
<li>Theoretical outline of the simulation</li>
<li>Implementation</li>
<li>Data visualization</li>
</ul>
<h2><a class="anchor" id="autotoc_md1"></a>
Theoretical outline of the simulation</h2>
<p >The goal of the simulation is to initiate a spherical triangulation and use a metropolis scheme to update the spherical triangulation, while enforcing the following energy</p>
<p ><img src="https://latex.codecogs.com/svg.latex?\Large&space;E=\frac{\kappa}{2}\int\mathrm{d}A(2H)^2+K_A\frac{(A-A_0)^2}{A_0}+K_V\frac{(V-V_t)^2}{V_t}," alt="energy function" class="inline"/></p>
<p >Where the first term is the Canham-Helfrich energy and minimizes the curvature (which makes the triangulation behave like a biological membrane [<a href="https://doi.org/10.1016/S0022-5193(70)80032-7">Canham1970</a>, <a href="https://doi-org.tudelft.idm.oclc.org/10.1515/znc-1973-11-1209">Helfrich1973</a>], the second and third terms are fixing the area and volume respectively, with harmonic potentials. The area is fixed to its initial value whereas the target volume is <code>60%</code> of the original sphere volume, i.e.</p>
<p ><img src="https://latex.codecogs.com/svg.latex?\Large&space;V_t=0.6V_0." alt="target volume" class="inline"/></p>
<p >The constant <img src="https://latex.codecogs.com/svg.latex?\Large&space;\kappa" alt="kappa" class="inline"/> is the bending rigidity which determines how easy it is to bend the membrane. The constants <img src="https://latex.codecogs.com/svg.latex?\Large&space;K_A" alt="kappa" class="inline"/> and <img src="https://latex.codecogs.com/svg.latex?\Large&space;K_V" alt="kappa" class="inline"/> are lagrange multipliers that fix the area and volume respectively. Their values do not have physical interpretations but the larger they are more important it becomes for the simulation to fix their respective values precisely. This means that if we make these constants too small the deviations from desired target values will be unacceptably large. However, if we make these constants too large, then the area and volume terms will penalize even small deviations too strongly, which means that all Monte Carlo steps will be rejected as soon as the target values are reached and the simulation will ignore the curvature term. Choosing <img src="https://latex.codecogs.com/svg.latex?\Large&space;K_A" alt="kappa" class="inline"/> and <img src="https://latex.codecogs.com/svg.latex?\Large&space;K_V" alt="kappa" class="inline"/> is usually done by trial and error (that's what I did here).</p>
<h2><a class="anchor" id="autotoc_md2"></a>
Implementation</h2>
<h3><a class="anchor" id="autotoc_md3"></a>
Overview</h3>
<p >There are four main ingredients that we need to implement with flippy to simulate the above described system</p><ol type="1">
<li>Implementation of the energy function and the <code>struct</code> containing all the function parameters.</li>
<li>Initiate a triangulation.</li>
<li>Initiate the builtin Monte Carlo updater abd connect it with the initiated triangulation and the energy function.</li>
<li>Write the update loop. This step specifies in which order the nodes should be moved and flipped any external parameter should change during the updating.<ol type="a">
<li>We will use this step to slowly transform the initial condition of the triangulation (a sphere) to a configuration that has the proper target volume,</li>
<li>then we will equilibrate the triangulation at that target volume</li>
<li>and finally we will decrease the temperature of the simulation to suppress noise that is inherent to Monte Carlo updating schemes.</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md4"></a>
Energy function</h3>
<p >The energy function that we define here will be used by the <code>MonteCarloUpdater</code> class of flippy. This means that the signature of the function needs to be exactly what <code>MonteCarloUpdater</code> class expects, namely: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">double surface_energy(fp::Node&lt;double, int&gt; const&amp;, </div>
<div class="line">                      fp::Triangulation&lt;double, int&gt; const&amp; , </div>
<div class="line">                      EnergyParameters const&amp; )</div>
</div><!-- fragment --><p> The first argument of the function is the constant reference to the node (that is being updated), the second argument is a constant reference to the triangulation that the node is part of and the first argument can be anything as long as we specify that in the <code>MonteCarloUpdater</code> declaration later. In this case we want to pass a <code>struct</code> that holds all the parameters that are necessary in the energy function. We call this custom struct <code><a class="el" href="struct_energy_parameters.html">EnergyParameters</a></code>, which is defined as follows: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">struct EnergyParameters{double kappa, K_V, K_A, V_t, A_t;};</div>
</div><!-- fragment --><p> and later initialized as: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">EnergyParameters prms{.kappa=10 /*kBT*/,</div>
<div class="line">                          .K_V=100 /*kBT/area*/, .K_A=1000 /*kBT/volume*/,</div>
<div class="line">                          .V_t=0.6*sphere_vol(R), .A_t=sphere_area(R)};</div>
</div><!-- fragment --><p> where</p><ul>
<li><code>R</code> is the initial radius of the triangulation, and is initializes such that the triangles barely not overlap</li>
<li><code>sphere_vol</code> and <code>sphere_area</code> are functions defined in the main file and return the volume and area of a sphere of given radius.</li>
</ul>
<p >The values for area and volume targets are given in arbitrary units, since this simulation does not have a physical length scale.</p>
<p >The actual body of the energy function then looks as follows: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">double surface_energy([[maybe_unused]]fp::Node&lt;double, int&gt; const&amp; node,</div>
<div class="line">                      fp::Triangulation&lt;double, int&gt; const&amp; trg,</div>
<div class="line">                      EnergyParameters const&amp; prms){</div>
<div class="line">    double V = trg.global_geometry().volume;</div>
<div class="line">    double A = trg.global_geometry().area;</div>
<div class="line">    double dV = V-prms.V_t;</div>
<div class="line">    double dA = A-prms.A_t;</div>
<div class="line">    double energy = prms.kappa*trg.global_geometry().unit_bending_energy +</div>
<div class="line">                    prms.K_V*dV*dV/prms.V_t + prms.K_A*dA*dA/prms.A_t;</div>
<div class="line">    return energy;</div>
<div class="line">}</div>
</div><!-- fragment --><p> where the input argument node has the compiler directive <code>[[maybe_unused]]</code> prepended, which tells the compiler that this variable is not used in the function body.</p>
<h3><a class="anchor" id="autotoc_md5"></a>
Triangulation declaration</h3>
<p >In order to create a spherical triangulation we can initiate a <code>Triangulation</code> class: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::Triangulation&lt;double, int, fp::SPHERICAL_TRIANGULATION&gt; tr(n_triang, R, r_Verlet);</div>
</div><!-- fragment --><p> here <code>fp</code> is flippy's namespace. The first two template arguments specify what types of floating point and integral numbers the triangulation is supposed to use. One could have specified <code>float</code> and <code>short</code> instead. The third argument specifies the type of triangulation, in this case we want to use a spherical one. However, the last template argument is not necessary since spherical triangulation is already default. This means that we can also write: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::Triangulation&lt;double, int&gt; guv(n_triang, R, r_Verlet);</div>
</div><!-- fragment --><p> The arguments of the triangulation instantiation are <code>n_triang</code> which specifies the level of triangulation. flippy's current implementation starts from an icosahedron and after <code>n_triang</code> steps of sub-triangulation, one gets</p>
<p ><img src="https://latex.codecogs.com/svg.latex?\Large&space;N_{nodes}=12+30n_{triang}+20\frac{n_{triang}(n_{triang}-1)}{2}," alt="node number" class="inline"/></p>
<p >number of nodes. The second variable <code>R</code> specifies the radius of triangulated sphere and the variable <code>r_Verlet</code> specifies the Verlet radius for the nodes of the triangulation. This sets the size of the <a href="https://en.wikipedia.org/wiki/Verlet_list">Verlet list</a>, which is the list of spatially close nodes. This information is necessary to efficiently implement non-selfintersection property of the membrane.</p>
<p >After the above declaration we will have access to the triangulation via the declared variable <code>guv</code>.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
Monte Carlo updater declaration</h3>
<p >The monte carlo updater needs to have information about the triangulation, the energy function and the parameter struct, all of which we have already defined and initiated. Additionally, we also need a random number generator.</p>
<p >The declaration can be done as follows: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::MonteCarloUpdater&lt;double, int, EnergyParameters, std::mt19937, </div>
<div class="line">                      fp::SPHERICAL_TRIANGULATION&gt; </div>
<div class="line">                      mc_updater(guv, prms, surface_energy, rng, l_min, l_max);</div>
</div><!-- fragment --><p> The template arguments again specify what type of updater we want.</p><ul>
<li><code>double</code> and <code>int</code> specify types of floating point and integral numbers used in updating (same as in triangulation). It is important that we use the same floating point type here as in the triangulation and in the return value of the energy function.</li>
<li><code><a class="el" href="struct_energy_parameters.html">EnergyParameters</a></code> specifies the type of the third argument of the energy function.</li>
<li><code>std::mt19937</code> specifies the type of the random number generator. The provided value here is a Mersenne Twister random number generator, which is part of <code>c++</code> standard library.</li>
<li><code><a class="el" href="namespacefp.html#a6ac3c08b4c402e40a3f270818345078aa4818fa0ff44979ed665568888d681703">fp::SPHERICAL_TRIANGULATION</a></code> specifies the triangulation type (not optional in this case), which has to match the triangulation type of the <code>Triangulation</code> class.</li>
</ul>
<p >The instantiation parameters have the following meaning:</p><ul>
<li><code>guv</code> name of the <code>Triangulation</code> class instance that we declared.</li>
<li><code>prms</code> name of the <code><a class="el" href="struct_energy_parameters.html">EnergyParameters</a></code> struct instance that we declared.</li>
<li><code>surface_energy</code> name of the energy function that we defined.</li>
<li><code>rng</code> is the name of the instance of the random number generator. This generator needs to be declared before the <code>mc_updater</code> in the code as <div class="fragment"><div class="line"> {c++}</div>
<div class="line">std::random_device random_number_generator_seed;</div>
<div class="line">std::mt19937 rng(random_number_generator_seed()); </div>
</div><!-- fragment --></li>
<li><code>l_min</code> minimum distance between the triangulation nodes that is allowed during updating.</li>
<li><code>l_max</code> maximum distance between connected triangulation nodes that is allowed during updating.</li>
</ul>
<p >The instance <code>mc_updater</code> now provides access to functions that can attempt an update of the triangulation.</p>
<ul>
<li><code>move_MC_updater</code> expects a node and a displacement vector and will attempt to update that node's position by the displacement vector</li>
<li><code>flip_MC_updater</code> expects a node and will randomly choose one of that nodes neighbours and attempt to flip the bond between the two nodes.</li>
</ul>
<h3><a class="anchor" id="autotoc_md7"></a>
The update loop</h3>
<p >The simplest update loop would be one where we loop through all nodes, and use the <code>MonteCarloUpdater</code> to attempt an update, and then repeat this for a set number of times specified by <code>max_mc_steps</code>. This would look like this</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">for(int t=1; t&lt;max_mc_steps+1; ++t){</div>
<div class="line">    for (auto const&amp; node: guv.nodes()) { </div>
<div class="line">      displ = {displ_distr(rng), displ_distr(rng), displ_distr(rng)};</div>
<div class="line">      mc_updater.move_MC_updater(node, displ);</div>
<div class="line">      mc_updater.flip_MC_updater(node);</div>
<div class="line">  }</div>
<div class="line">} </div>
</div><!-- fragment --><p> Here we used some new variables and functions, that we define before the loop in the main file:</p><ul>
<li><code>displ</code> is a 3 dimensional vector of displacements of type <code><a class="el" href="classfp_1_1vec3.html">fp::vec3</a>&lt;double&gt;</code>, which is a flippy builtin type.</li>
<li><code>displ_distr</code> is a uniform distribution from which displacements are drawn.</li>
</ul>
<p >This update loop would work, but usually we want to do a bit more than what's implemented there. For starters, we want to separate the moving events from flipping events. We want to create a separate vector for node id's which we can shuffle in each Monte Carlo step. And finally, we want to squish the initial sphere a bit, to break the initial spherical symmetry, since the final biconcave shapes that we expect are oblate. This we will do with the <code>scale_node_coordinates</code> method of the triangulation.</p>
<div class="fragment"><div class="line"> {c++}</div>
<div class="line">tr.scale_node_coordinates(1, 1, 0.8); // squish the sphere in z direction to break the initial symmetry. This speeds up the convergence to a biconcave shape greatly</div>
<div class="line"> </div>
<div class="line">std::vector&lt;int&gt; shuffled_ids;</div>
<div class="line">shuffled_ids.reserve(guv.size());</div>
<div class="line">for(auto const&amp; node: guv.nodes()){ shuffled_ids.push_back(node.id);}</div>
<div class="line"> </div>
<div class="line">for(int mc_step=0; mc_step&lt;max_mc_steps; ++mc_step){</div>
<div class="line">    for (int node_id: shuffled_ids) { // we first loop through all the beads and move them</div>
<div class="line">        displ = {displ_distr(rng), displ_distr(rng), displ_distr(rng)};</div>
<div class="line">        mc_updater.move_MC_updater(guv[node_id], displ); // guv[node_id] returns the node which has id=node_id</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::shuffle(shuffled_ids.begin(), shuffled_ids.end(), rng); // then we shuffle the bead_ids</div>
<div class="line">    </div>
<div class="line">    for (int node_id: shuffled_ids) { // then we loop through all of them again and try to flip their bonds</div>
<div class="line">        mc_updater.flip_MC_updater(guv[node_id]);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md8"></a>
Data saving</h3>
<p >The least effort way to save a snapshot of the triangulation is to use the builtin <code>make_egg</code> method. Which serializes every node of the triangulation to a <code>json</code> object. </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::Json data_final = guv.make_egg_data(); </div>
</div><!-- fragment --><p> and then we can use one of flippy's helper functions <code>dump_json</code> to save the data to a file: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::json_dump(&quot;test_run_final&quot;, data_final);</div>
</div><!-- fragment --><p> The above command will save the data to a <code>test_run_final.json</code> file in the same folder where the executable was executed.</p>
<p >If one wants to continue the simulation after the final configurateion then the saved data can be used to initialize a triangulation: </p><div class="fragment"><div class="line"> {c++}</div>
<div class="line">fp::Json loaded_data = fp::json_read(&quot;test_run_final.json&quot;);</div>
<div class="line">fp::Triangulation&lt;double, int&gt; loaded_guv(loaded_data, r_Verlet);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md9"></a>
Data visualization</h2>
<p >This folder also provides a <code>data_vizualization.py</code> python file. If this file is run in the same folder, where <code>test_run_init.json</code> and <code>test_run_final.json</code> json files are saved (the output files of the executable), then the python file will generate two plots. That of the initial and final configurations of a run. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
