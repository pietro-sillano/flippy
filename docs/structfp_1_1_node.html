<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>flippy: fp::Node&lt; Real, Index &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flippy_icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">flippy
   </div>
   <div id="projectbrief">a c++20 package for dynamically triangulated membrane simulations.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structfp_1_1_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structfp_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fp::Node&lt; Real, Index &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A data structure containing all geometric and topological information associated with a node.  
 <a href="structfp_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_nodes_8hpp_source.html">Nodes.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for fp::Node&lt; Real, Index &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structfp_1_1_node__coll__graph.png" border="0" usemap="#afp_1_1_node_3_01_real_00_01_index_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="afp_1_1_node_3_01_real_00_01_index_01_4_coll__map" id="afp_1_1_node_3_01_real_00_01_index_01_4_coll__map">
<area shape="rect" title="A data structure containing all geometric and topological information associated with a node." alt="" coords="178,123,341,148"/>
<area shape="rect" title=" " alt="" coords="5,5,60,31"/>
<area shape="rect" title=" " alt="" coords="84,5,133,31"/>
<area shape="rect" title=" " alt="" coords="201,5,302,31"/>
<area shape="rect" title=" " alt="" coords="326,5,441,31"/>
<area shape="rect" title=" " alt="" coords="465,5,645,31"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf3d0a7d0c7425beb820fb453c240ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#acf3d0a7d0c7425beb820fb453c240ed3">pop_nn</a> (Index to_pop_nn_id)</td></tr>
<tr class="memdesc:acf3d0a7d0c7425beb820fb453c240ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and deletes the element with the id <code>to_pop_nn_id</code> in the <code>nn_id</code> vector.  <br /></td></tr>
<tr class="separator:acf3d0a7d0c7425beb820fb453c240ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5959f64aafa9cd65ff0e5fed21064da3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a5959f64aafa9cd65ff0e5fed21064da3">find_nns_loc_pointer</a> (Index nn_id)</td></tr>
<tr class="separator:a5959f64aafa9cd65ff0e5fed21064da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc063b2ef6645bfea2e258260a5236a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#aefc063b2ef6645bfea2e258260a5236a">emplace_nn_id</a> (Index to_emplace_nn_id, <a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;to_emplace_nn_pos, Index loc_idx)</td></tr>
<tr class="separator:aefc063b2ef6645bfea2e258260a5236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#aa9bf52cc0dc958fca2868f640cdbcb21">get_distance_vector_to</a> (Index nn_id) const</td></tr>
<tr class="memdesc:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can provide the stored distance vector to the next neighbor.  <br /></td></tr>
<tr class="separator:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7daf80f3048d114e9adfe442c5069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a8bc7daf80f3048d114e9adfe442c5069">operator==</a> (<a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;other_node) const =default</td></tr>
<tr class="memdesc:a8bc7daf80f3048d114e9adfe442c5069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default equality operator.  <br /></td></tr>
<tr class="separator:a8bc7daf80f3048d114e9adfe442c5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4743d523ce7d4e1ea613d685af1da9be"><td class="memItemLeft" align="right" valign="top"><a id="a4743d523ce7d4e1ea613d685af1da9be" name="a4743d523ce7d4e1ea613d685af1da9be"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="memdesc:a4743d523ce7d4e1ea613d685af1da9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global id of the <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>, which is a number between 0 and max_number_of_nodes - 1. <br /></td></tr>
<tr class="separator:a4743d523ce7d4e1ea613d685af1da9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a740dc7b51916c9ac29674b7c6dae5dbc">area</a></td></tr>
<tr class="memdesc:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voronoi area associated with the node.  <br /></td></tr>
<tr class="separator:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0618b10496535a019b5a99cdc721dca"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ae0618b10496535a019b5a99cdc721dca">volume</a></td></tr>
<tr class="memdesc:ae0618b10496535a019b5a99cdc721dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the node is part of a closed surface triangulation, then the <code>volume</code> contains the volume of the tetrahedron connected to each voronoi cell sub-triangle and the center of the lab coordinate system as defined in <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>.  <br /></td></tr>
<tr class="separator:ae0618b10496535a019b5a99cdc721dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a475a50241308f3dd99313c2760f26"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a65a475a50241308f3dd99313c2760f26">unit_bending_energy</a></td></tr>
<tr class="memdesc:a65a475a50241308f3dd99313c2760f26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>unit_bending_energy</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Elasticity_of_cell_membranes">Helfrich bending energy</a> with bending rigidity 1 and gaussian bending stiffness 0.  <br /></td></tr>
<tr class="separator:a65a475a50241308f3dd99313c2760f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be91bc755ce112845d1f0a0b96c976"><td class="memItemLeft" align="right" valign="top"><a id="a10be91bc755ce112845d1f0a0b96c976" name="a10be91bc755ce112845d1f0a0b96c976"></a>
<a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pos</b></td></tr>
<tr class="memdesc:a10be91bc755ce112845d1f0a0b96c976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of the node in the lab frame. <br /></td></tr>
<tr class="separator:a10be91bc755ce112845d1f0a0b96c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b801251ab545ad8d931d09583920537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537">curvature_vec</a></td></tr>
<tr class="memdesc:a2b801251ab545ad8d931d09583920537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curvature vector of the node.  <br /></td></tr>
<tr class="separator:a2b801251ab545ad8d931d09583920537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a></td></tr>
<tr class="memdesc:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the global ids of the current node's next neighbors.  <br /></td></tr>
<tr class="separator:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b5f362addd1bb5249f573b16d0a90"><td class="memItemLeft" align="right" valign="top"><a id="a7d7b5f362addd1bb5249f573b16d0a90" name="a7d7b5f362addd1bb5249f573b16d0a90"></a>
std::vector&lt; <a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nn_distances</b></td></tr>
<tr class="memdesc:a7d7b5f362addd1bb5249f573b16d0a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance vectors pointing from the node to its next neighbors. <br /></td></tr>
<tr class="separator:a7d7b5f362addd1bb5249f573b16d0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="memItemLeft" align="right" valign="top"><a id="aff4450fcb2eb2524fcb0c9025b69bc6a" name="aff4450fcb2eb2524fcb0c9025b69bc6a"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>verlet_list</b></td></tr>
<tr class="memdesc:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Verlet list contains the ids of nodes that are close to this node. <br /></td></tr>
<tr class="separator:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ac8b3254d4da11f9069ce0cbc28aa0288">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;node)</td></tr>
<tr class="memdesc:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator that can print formatted output to standard out with all <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a> data fields.  <br /></td></tr>
<tr class="separator:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;floating_point_number Real, indexing_number Index&gt;<br />
struct fp::Node&lt; Real, Index &gt;</div><p>A data structure containing all geometric and topological information associated with a node. </p>
<p>This is a DUMB DATA STRUCTURE, meaning that it is not responsible for the coherence of the data it contains. For performance reasons, methods associated with <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a> struct will never check if the Node::curvature is the norm of the Node::curvature_vector or if the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> and <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to its next neighbors.">Node::nn_distances</a> are in the correct order. It is the responsibility of higher-order structures like <a class="el" href="structfp_1_1_nodes.html" title="Data structure containing all nodes of the Triangulation.">Nodes</a> and <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a> to check that correct data is stored and updated correctly. However, it does check the data for consistency. It will match the length of <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> and <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to its next neighbors.">Node::nn_distances</a> and pop and add both of them together. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Real</td><td>type that will be used for all floating point numbers inside this class/struct. Any data type that satisfies the floating_point_number concept is allowed, for example, <code>float</code>. </td></tr>
    <tr><td class="paramname">Index</td><td>type that will be used for all integer numbers inside this class/struct. Any data type that satisfies the indexing_number concept is allowed, for example, <code>unsigned int</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acf3d0a7d0c7425beb820fb453c240ed3" name="acf3d0a7d0c7425beb820fb453c240ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d0a7d0c7425beb820fb453c240ed3">&#9670;&#160;</a></span>pop_nn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::pop_nn </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>to_pop_nn_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find and deletes the element with the id <code>to_pop_nn_id</code> in the <code>nn_id</code> vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_pop_nn_id</td><td>Global id of the next neighbor <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>, which is a number between 0 and max_number_of_nodes - 1. This id is supposed to be removed from the next neighbor id vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this will lead to resizing of the vector, which can be expensive! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the provided next neighbor id is not part of the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a>, this function will fail silently. It will not delete anything and won't throw any errors or warnings;</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structfp_1_1_node_acf3d0a7d0c7425beb820fb453c240ed3_cgraph.png" border="0" usemap="#astructfp_1_1_node_acf3d0a7d0c7425beb820fb453c240ed3_cgraph" alt=""/></div>
<map name="astructfp_1_1_node_acf3d0a7d0c7425beb820fb453c240ed3_cgraph" id="astructfp_1_1_node_acf3d0a7d0c7425beb820fb453c240ed3_cgraph">
<area shape="rect" title="Find and deletes the element with the id to_pop_nn_id in the nn_id vector." alt="" coords="5,13,128,38"/>
<area shape="rect" href="structfp_1_1_node.html#a5959f64aafa9cd65ff0e5fed21064da3" title=" " alt="" coords="176,5,305,45"/>
</map>
</div>

</div>
</div>
<a id="a5959f64aafa9cd65ff0e5fed21064da3" name="a5959f64aafa9cd65ff0e5fed21064da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5959f64aafa9cd65ff0e5fed21064da3">&#9670;&#160;</a></span>find_nns_loc_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::find_nns_loc_pointer </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nn_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the global id of the next neighbor, this function can be used to locate it in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> vector.</p>
<p>This function is just a convenient wrapper around the <a href="https://en.cppreference.com/w/cpp/algorithm/find">std::find</a> function. </p><div class="fragment"><div class="line">std::find(<a class="code hl_variable" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a>.begin(), <a class="code hl_variable" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a>.end(), to_pop_nn_id);</div>
<div class="ttc" id="astructfp_1_1_node_html_ae2e0c5a97ae4f47cff41a692ac6ce79a"><div class="ttname"><a href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">fp::Node::nn_ids</a></div><div class="ttdeci">std::vector&lt; Index &gt; nn_ids</div><div class="ttdoc">A vector containing the global ids of the current node's next neighbors.</div><div class="ttdef"><b>Definition:</b> Nodes.hpp:93</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn_id</td><td>Global id of the next neighbor <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>, which is a number between 0 and max_number_of_nodes - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <code>nn_id</code> is contained in <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> then the pointer to the position of that id in the <code>nn_ids</code> vector will be returned. Otherwise <code>nn_ids.end()</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not responsible for graceful handling of <code>nn_id</code>'s that are not found in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> vector. If the <code>nn_id</code> is not contained in <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> then the <code>nn_ids.end()</code> iterator will be returned. It is up to the user to perform the necessary checks to avoid undefined behavior that might result from trying to delete uninitiated memory.</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structfp_1_1_node_a5959f64aafa9cd65ff0e5fed21064da3_icgraph.png" border="0" usemap="#astructfp_1_1_node_a5959f64aafa9cd65ff0e5fed21064da3_icgraph" alt=""/></div>
<map name="astructfp_1_1_node_a5959f64aafa9cd65ff0e5fed21064da3_icgraph" id="astructfp_1_1_node_a5959f64aafa9cd65ff0e5fed21064da3_icgraph">
<area shape="rect" title=" " alt="" coords="176,5,305,45"/>
<area shape="rect" href="structfp_1_1_node.html#acf3d0a7d0c7425beb820fb453c240ed3" title="Find and deletes the element with the id to_pop_nn_id in the nn_id vector." alt="" coords="5,13,128,38"/>
</map>
</div>

</div>
</div>
<a id="aefc063b2ef6645bfea2e258260a5236a" name="aefc063b2ef6645bfea2e258260a5236a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc063b2ef6645bfea2e258260a5236a">&#9670;&#160;</a></span>emplace_nn_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::emplace_nn_id </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>to_emplace_nn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;&#160;</td>
          <td class="paramname"><em>to_emplace_nn_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>loc_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function can be used to add new next neighbors to this node.</p>
<p>This function constructs <code>to_emplace_nn_id</code> right before <code>to_emplace_pos</code>, i.e. if to_emplace_nn_id is 3, to_emplace_nn_id will be constructed right before the 3rd element and will become the new 3rd element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_emplace_nn_id</td><td>Global id of the next neighbor <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>, which is a number between 0 and max_number_of_nodes - 1. This id is supposed to be added to the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> vector of this node. </td></tr>
    <tr><td class="paramname">to_emplace_nn_pos</td><td>const reference to the 3 dimensional position vector (type vec3&lt;Real&gt;) containing the position of the new next neighbour. This input is used to calculate the correct distance between this node and the new next neighbor, which will then be added to the <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to its next neighbors.">Node::nn_distances</a> vector. </td></tr>
    <tr><td class="paramname">loc_idx</td><td>Local index in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> vector, a number between 0 and Node::nn_ids.size() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function causes the resizing of two vectors, which can be costly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Making next neighbors is a symmetric operation. I.e., if node one becomes the next neighbor of node two, node two also has to become the next neighbor of node one. However, this function is not responsible for this relationship. It only adds a new next neighbor to this node, and the higher-order structures, like <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a>, are responsible for guaranteeing the reciprocal relationship. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfp_1_1_triangulation.html#a11ee6051e9db388def8aaed68b1841d4" title="Adds a new node to the next neighbor list of a given node and calculates their mutual distance.">Triangulation::emplace_before(Index, Index, Index)</a></dd></dl>

</div>
</div>
<a id="aa9bf52cc0dc958fca2868f640cdbcb21" name="aa9bf52cc0dc958fca2868f640cdbcb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bf52cc0dc958fca2868f640cdbcb21">&#9670;&#160;</a></span>get_distance_vector_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const  &amp; <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::get_distance_vector_to </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nn_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can provide the stored distance vector to the next neighbor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn_id</td><td>Global id of the next neighbor <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>, which is a number between 0 and max_number_of_nodes - 1.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the distance currently stored in the <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to its next neighbors.">Node::nn_distances</a> vector for the requested next neighbor. If the provided <code>nn_id</code> can not be found in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="A vector containing the global ids of the current node&#39;s next neighbors.">Node::nn_ids</a> vector, then the function writes an error message to standard error output and terminates the program with exit code 12. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function with a wrong argument will cause the termination of the program.</dd></dl>

</div>
</div>
<a id="a8bc7daf80f3048d114e9adfe442c5069" name="a8bc7daf80f3048d114e9adfe442c5069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7daf80f3048d114e9adfe442c5069">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other_node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_node</td><td>constant reference to the other <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both nodes are equal. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac8b3254d4da11f9069ce0cbc28aa0288" name="ac8b3254d4da11f9069ce0cbc28aa0288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b3254d4da11f9069ce0cbc28aa0288">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Streaming operator that can print formatted output to standard out with all <a class="el" href="structfp_1_1_node.html" title="A data structure containing all geometric and topological information associated with a node.">Node</a> data fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>This is intended to be std::cout or any other std::ofstream reference. </td></tr>
    <tr><td class="paramname">node</td><td>The streamed node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Updated stream. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a740dc7b51916c9ac29674b7c6dae5dbc" name="a740dc7b51916c9ac29674b7c6dae5dbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740dc7b51916c9ac29674b7c6dae5dbc">&#9670;&#160;</a></span>area</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::area</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Voronoi area associated with the node. </p>
<p>The Voronoi area is the sum of (mixed) Voronoi areas inside the triangles, incident to the node. Definition follows <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>.  </p><p class="formulaDsp">
\[
A_{i} = \sum_{j} A&#39;_{ij}.
\]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfp_1_1_triangulation.html#a3e43dfd4b4c9cfd10c5bf4174f2a85d1" title="The node-associated area inside a triangle.">Triangulation::mixed_area</a> See Figure tr1. C in <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a>. </dd>
<dd>
<a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537" title="Curvature vector of the node.">Node::curvature_vec</a> <a class="el" href="classfp_1_1_triangulation.html#a5d5763865ac706a2e800ed306d070d68" title="Update the geometric quantities associated with the given node.">Triangulation::update_bulk_node_geometry(Index)</a> </dd></dl>

</div>
</div>
<a id="ae0618b10496535a019b5a99cdc721dca" name="ae0618b10496535a019b5a99cdc721dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0618b10496535a019b5a99cdc721dca">&#9670;&#160;</a></span>volume</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::volume</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the node is part of a closed surface triangulation, then the <code>volume</code> contains the volume of the tetrahedron connected to each voronoi cell sub-triangle and the center of the lab coordinate system as defined in <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>. </p>
<p>This means that the volume of an individual node does not have a proper physical interpretation. Only the sum of all node volumes, which is given by the triangulation is interpretable as a physical volume of an object. The definition follows <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>.  </p><p class="formulaDsp">
\[
V_{ij} = A_{ij} \vec{x}_{i}\cdot \frac{\vec{n}_{ij,j+1}}{\| \vec{n}_{ij,j+1} \|}.
\]
</p>
<p> See Figure tr1. D in <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537" title="Curvature vector of the node.">Node::curvature_vec</a> <a class="el" href="classfp_1_1_triangulation.html#a5d5763865ac706a2e800ed306d070d68" title="Update the geometric quantities associated with the given node.">Triangulation::update_bulk_node_geometry(Index)</a> </dd></dl>

</div>
</div>
<a id="a65a475a50241308f3dd99313c2760f26" name="a65a475a50241308f3dd99313c2760f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a475a50241308f3dd99313c2760f26">&#9670;&#160;</a></span>unit_bending_energy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::unit_bending_energy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>unit_bending_energy</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Elasticity_of_cell_membranes">Helfrich bending energy</a> with bending rigidity 1 and gaussian bending stiffness 0. </p>
<p class="formulaDsp">
\[
 \mathrm{unit\_bending\_energy} = \frac{1}{2} A_{\mathrm{node}} (2 H_{node})^2
\]
</p>
<p> where \( H_{node} \) is the mean curvature of the node given by:  </p><p class="formulaDsp">
\[
H_{node}^2 = \frac{\vec{K}_{node}}{2A_{node}} \cdot \frac{\vec{K}_{node}}{2A_{node}}
\]
</p>
<p>, with \( \vec{K} \) denoting the Node::curvature_vector. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537" title="Curvature vector of the node.">Node::curvature_vec</a> <a class="el" href="classfp_1_1_triangulation.html#a5d5763865ac706a2e800ed306d070d68" title="Update the geometric quantities associated with the given node.">Triangulation::update_bulk_node_geometry(Index)</a> </dd></dl>

</div>
</div>
<a id="a2b801251ab545ad8d931d09583920537" name="a2b801251ab545ad8d931d09583920537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b801251ab545ad8d931d09583920537">&#9670;&#160;</a></span>curvature_vec</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt;Real&gt; <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::curvature_vec</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Curvature vector of the node. </p>
<p>The definition of the curvature vector follows <a href="https://doi.org/10.1007/978-3-662-05105-4_2">Meyer et al. 2003</a>.  </p><p class="formulaDsp">
\[
\vec{K}_i = \frac{1}{2A_i}\sum_{j(i)} \left( \cot\left(\alpha_{ij}^{j+1}\right) + \cot\left(\alpha_{ij}^{j-1}\right) \right)\vec{\ell}_{ij}
\]
</p>
<p> See Figure tr1. B in <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537" title="Curvature vector of the node.">Node::curvature_vec</a> <a class="el" href="classfp_1_1_triangulation.html#a5d5763865ac706a2e800ed306d070d68" title="Update the geometric quantities associated with the given node.">Triangulation::update_bulk_node_geometry(Index)</a> </dd></dl>

</div>
</div>
<a id="ae2e0c5a97ae4f47cff41a692ac6ce79a" name="ae2e0c5a97ae4f47cff41a692ac6ce79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e0c5a97ae4f47cff41a692ac6ce79a">&#9670;&#160;</a></span>nn_ids</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Index&gt; <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::nn_ids</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A vector containing the global ids of the current node's next neighbors. </p>
<p><code>nn_ids</code> contains the ids of nodes that are connected to this node in the triangulation. The next neighbors that are also mutual neighbors in the triangulation are stored sequentially in the vector. The last and the first elements are also neighbors, i.e., the nn_ids vector wraps around. During the calculation, this is facilitated through the use of <a class="el" href="structfp_1_1_neighbors.html">fp::Neighbors</a>. </p><dl class="section note"><dt>Note</dt><dd>The order of the next neighbors matters for the proper function of <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">fp::Triangulation</a> but is not guaranteed by this data structure. See Figure tr1. A, in <a class="el" href="classfp_1_1_triangulation.html" title="Implementation of Triangulation of two-dimensional surfaces in 3D.">Triangulation</a>. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>flippy/<a class="el" href="_nodes_8hpp_source.html">Nodes.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefp.html">fp</a></li><li class="navelem"><a class="el" href="structfp_1_1_node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6 </li>
  </ul>
</div>
</body>
</html>
