<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>flippy: fp::Node&lt; Real, Index &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="flippy_icon.png"/></td>
  <td id="projectalign">
   <div id="projectname">flippy
   </div>
   <div id="projectbrief">a c++20 package for dynamically triangulated membrane simulations.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('structfp_1_1_node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="structfp_1_1_node-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">fp::Node&lt; Real, Index &gt; Struct Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Data structure containing all geometric and topological information associated to a node.  
 <a href="structfp_1_1_node.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_nodes_8hpp_source.html">Nodes.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for fp::Node&lt; Real, Index &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structfp_1_1_node__coll__graph.svg" width="651" height="154"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acf3d0a7d0c7425beb820fb453c240ed3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#acf3d0a7d0c7425beb820fb453c240ed3">pop_nn</a> (Index to_pop_nn_id)</td></tr>
<tr class="memdesc:acf3d0a7d0c7425beb820fb453c240ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the element with the id to_pop_nn_id in the nn_id vector and deletes it.  <a href="structfp_1_1_node.html#acf3d0a7d0c7425beb820fb453c240ed3">More...</a><br /></td></tr>
<tr class="separator:acf3d0a7d0c7425beb820fb453c240ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5959f64aafa9cd65ff0e5fed21064da3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a5959f64aafa9cd65ff0e5fed21064da3">find_nns_loc_pointer</a> (Index nn_id)</td></tr>
<tr class="separator:a5959f64aafa9cd65ff0e5fed21064da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc063b2ef6645bfea2e258260a5236a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#aefc063b2ef6645bfea2e258260a5236a">emplace_nn_id</a> (Index to_emplace_nn_id, <a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;to_emplace_nn_pos, Index loc_idx)</td></tr>
<tr class="separator:aefc063b2ef6645bfea2e258260a5236a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#aa9bf52cc0dc958fca2868f640cdbcb21">get_distance_vector_to</a> (Index nn_id) const</td></tr>
<tr class="memdesc:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function can provide the stored distance vector to a next neighbour.  <a href="structfp_1_1_node.html#aa9bf52cc0dc958fca2868f640cdbcb21">More...</a><br /></td></tr>
<tr class="separator:aa9bf52cc0dc958fca2868f640cdbcb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc7daf80f3048d114e9adfe442c5069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a8bc7daf80f3048d114e9adfe442c5069">operator==</a> (<a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;other_node) const =default</td></tr>
<tr class="memdesc:a8bc7daf80f3048d114e9adfe442c5069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default equality operator.  <a href="structfp_1_1_node.html#a8bc7daf80f3048d114e9adfe442c5069">More...</a><br /></td></tr>
<tr class="separator:a8bc7daf80f3048d114e9adfe442c5069"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4743d523ce7d4e1ea613d685af1da9be"><td class="memItemLeft" align="right" valign="top"><a id="a4743d523ce7d4e1ea613d685af1da9be" name="a4743d523ce7d4e1ea613d685af1da9be"></a>
Index&#160;</td><td class="memItemRight" valign="bottom"><b>id</b></td></tr>
<tr class="memdesc:a4743d523ce7d4e1ea613d685af1da9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global id of the <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> which is a number between 0 and max_number_of_nodes - 1. <br /></td></tr>
<tr class="separator:a4743d523ce7d4e1ea613d685af1da9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="memItemLeft" align="right" valign="top"><a id="a740dc7b51916c9ac29674b7c6dae5dbc" name="a740dc7b51916c9ac29674b7c6dae5dbc"></a>
Real&#160;</td><td class="memItemRight" valign="bottom"><b>area</b></td></tr>
<tr class="memdesc:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Voronoi area associated to the node. <br /></td></tr>
<tr class="separator:a740dc7b51916c9ac29674b7c6dae5dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0618b10496535a019b5a99cdc721dca"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ae0618b10496535a019b5a99cdc721dca">volume</a></td></tr>
<tr class="memdesc:ae0618b10496535a019b5a99cdc721dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the node is part of a closed surface triangulation, then the <code>volume</code> contains the volume of the tetrahedron connected to each voronoi cell sub-triangle and the center of the lab coordinate system as defined in <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>.  <a href="structfp_1_1_node.html#ae0618b10496535a019b5a99cdc721dca">More...</a><br /></td></tr>
<tr class="separator:ae0618b10496535a019b5a99cdc721dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a475a50241308f3dd99313c2760f26"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#a65a475a50241308f3dd99313c2760f26">unit_bending_energy</a></td></tr>
<tr class="memdesc:a65a475a50241308f3dd99313c2760f26"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>unit_bending_energy</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Elasticity_of_cell_membranes">Helfrich bending energy</a> with bending rigidity 1 and gaussian bending stiffness 0.  <a href="structfp_1_1_node.html#a65a475a50241308f3dd99313c2760f26">More...</a><br /></td></tr>
<tr class="separator:a65a475a50241308f3dd99313c2760f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10be91bc755ce112845d1f0a0b96c976"><td class="memItemLeft" align="right" valign="top"><a id="a10be91bc755ce112845d1f0a0b96c976" name="a10be91bc755ce112845d1f0a0b96c976"></a>
<a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>pos</b></td></tr>
<tr class="memdesc:a10be91bc755ce112845d1f0a0b96c976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Position of the node in the lab frame. <br /></td></tr>
<tr class="separator:a10be91bc755ce112845d1f0a0b96c976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b801251ab545ad8d931d09583920537"><td class="memItemLeft" align="right" valign="top"><a id="a2b801251ab545ad8d931d09583920537" name="a2b801251ab545ad8d931d09583920537"></a>
<a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>curvature_vec</b></td></tr>
<tr class="memdesc:a2b801251ab545ad8d931d09583920537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Curvature vector of the node as defined in <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>. <br /></td></tr>
<tr class="separator:a2b801251ab545ad8d931d09583920537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a></td></tr>
<tr class="memdesc:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing the global ids of current node's next neighbours.  <a href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">More...</a><br /></td></tr>
<tr class="separator:ae2e0c5a97ae4f47cff41a692ac6ce79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7b5f362addd1bb5249f573b16d0a90"><td class="memItemLeft" align="right" valign="top"><a id="a7d7b5f362addd1bb5249f573b16d0a90" name="a7d7b5f362addd1bb5249f573b16d0a90"></a>
std::vector&lt; <a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nn_distances</b></td></tr>
<tr class="memdesc:a7d7b5f362addd1bb5249f573b16d0a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance vectors pointing from the node to it's next neighbours. <br /></td></tr>
<tr class="separator:a7d7b5f362addd1bb5249f573b16d0a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="memItemLeft" align="right" valign="top"><a id="aff4450fcb2eb2524fcb0c9025b69bc6a" name="aff4450fcb2eb2524fcb0c9025b69bc6a"></a>
std::vector&lt; Index &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>verlet_list</b></td></tr>
<tr class="memdesc:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verlet list contains the ids of nodes that are close to this node. <br /></td></tr>
<tr class="separator:aff4450fcb2eb2524fcb0c9025b69bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfp_1_1_node.html#ac8b3254d4da11f9069ce0cbc28aa0288">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;node)</td></tr>
<tr class="memdesc:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator that can print formatted output to standard out with all data fields of the <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a>.  <a href="structfp_1_1_node.html#ac8b3254d4da11f9069ce0cbc28aa0288">More...</a><br /></td></tr>
<tr class="separator:ac8b3254d4da11f9069ce0cbc28aa0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;floating_point_number Real, indexing_number Index&gt;<br />
struct fp::Node&lt; Real, Index &gt;</div><p >Data structure containing all geometric and topological information associated to a node. </p>
<p >This is a DUMB DATA STRUCTURE, meaning that it is not responsible for the coherence of the data that it contains. For performance reasons methods associated to <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> struct will never check if the Node::curvature is the norm of the Node::curvature_vector or if the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> and <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to it&#39;s next neighbours.">Node::nn_distances</a> are in the correct order. It is the responsibility of higher order structures like <a class="el" href="structfp_1_1_nodes.html" title="Data structure containing all nodes of the Triangulation.">Nodes</a> and <a class="el" href="classfp_1_1_triangulation.html">Triangulation</a> to check that correct data is stored and updated correctly. However it does check the data for consistency. It will match the length of <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> and <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to it&#39;s next neighbours.">Node::nn_distances</a> and pop and add both of them together. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Real</td><td>type that will be used for all floating point numbers inside this class/struct. Any data type that satisfies the floating_point_number concept is allowed, for example <code>float</code>. </td></tr>
    <tr><td class="paramname">Index</td><td>type that will be used for all integer numbers inside this class/struct. Any data type that satisfies the indexing_number concept is allowed, for example <code>unsigned int</code>. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="acf3d0a7d0c7425beb820fb453c240ed3" name="acf3d0a7d0c7425beb820fb453c240ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3d0a7d0c7425beb820fb453c240ed3">&#9670;&#160;</a></span>pop_nn()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::pop_nn </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>to_pop_nn_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the element with the id to_pop_nn_id in the nn_id vector and deletes it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_pop_nn_id</td><td>Global id of the next neighbour <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> which is a number between 0 and max_number_of_nodes - 1. This id is supposed to be removed from the next neighbour id vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>this will lead to resizing of the vector, which can be expensive! </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>if the provided next neighbour id is not part of the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a>, this function will fail silently. It will not delete anything and won't throw any errors or warnings;</dd></dl>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structfp_1_1_node_acf3d0a7d0c7425beb820fb453c240ed3_cgraph.svg" width="311" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="a5959f64aafa9cd65ff0e5fed21064da3" name="a5959f64aafa9cd65ff0e5fed21064da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5959f64aafa9cd65ff0e5fed21064da3">&#9670;&#160;</a></span>find_nns_loc_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::find_nns_loc_pointer </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nn_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Given the global id of the next neighbour, this function can be used to locate it in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> vector.</p>
<p >This function is just a convenient wrapper around the <a href="https://en.cppreference.com/w/cpp/algorithm/find">std::find</a> function. </p><div class="fragment"><div class="line">std::find(<a class="code hl_variable" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a>.begin(), <a class="code hl_variable" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">nn_ids</a>.end(), to_pop_nn_id);</div>
<div class="ttc" id="astructfp_1_1_node_html_ae2e0c5a97ae4f47cff41a692ac6ce79a"><div class="ttname"><a href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a">fp::Node::nn_ids</a></div><div class="ttdeci">std::vector&lt; Index &gt; nn_ids</div><div class="ttdoc">Vector containing the global ids of current node's next neighbours.</div><div class="ttdef"><b>Definition:</b> Nodes.hpp:63</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn_id</td><td>Global id of the next neighbour <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> which is a number between 0 and max_number_of_nodes - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if <code>nn_id</code> is contained in <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> then the pointer to the position of that id in the <code>nn_ids</code> vector will be returned. Otherwise <code>nn_ids.end()</code>. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is not responsible for graceful handling of <code>nn_id</code>'s that are not found in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> vector. If the <code>nn_id</code> is not contained in <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> then the <code>nn_ids.end()</code> iterator will be returned. It is up to the user to perform the necessary checks to avoid undefined behaviour that might result from trying to delete uninitiated memory.</dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="structfp_1_1_node_a5959f64aafa9cd65ff0e5fed21064da3_icgraph.svg" width="311" height="51"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</div>

</div>
</div>
<a id="aefc063b2ef6645bfea2e258260a5236a" name="aefc063b2ef6645bfea2e258260a5236a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc063b2ef6645bfea2e258260a5236a">&#9670;&#160;</a></span>emplace_nn_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::emplace_nn_id </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>to_emplace_nn_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const &amp;&#160;</td>
          <td class="paramname"><em>to_emplace_nn_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>loc_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This function can be used to add new next neighbours to this node.</p>
<p >This function constructs <code>to_emplace_nn_id</code> right before <code>to_emplace_pos</code>, i.e. if to_emplace_nn_id is 3, to_emplace_nn_id will be constructed right before the 3rd element and will become the new 3rd element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_emplace_nn_id</td><td>Global id of the next neighbour <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> which is a number between 0 and max_number_of_nodes - 1. This id is supposed to be added to the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> vector of this node. </td></tr>
    <tr><td class="paramname">to_emplace_nn_pos</td><td>const reference to the 3 dimensional position vector (type vec3&lt;Real&gt;) containing the position of the new next neighbour. This input is used to calculate the correct distance between this node and the new next neighbour, which then will be added to the <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to it&#39;s next neighbours.">Node::nn_distances</a> vector. </td></tr>
    <tr><td class="paramname">loc_idx</td><td>Local index in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> vector, which is a number between 0 and Node::nn_ids.size() - 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function causes the resizing of two vectors, which can be costly. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Making next neighbours is a symmetric operation. I.e. if node 1 becomes the next neighbour of node 2 then node two also has to become the next neighbour of node 1. However this function does is not responsible for this relationship. It only adds a new next neighbour to this node and the higher order structures Like <a class="el" href="classfp_1_1_triangulation.html">Triangulation</a> is responsible for guaranteeing the reciprocal relationship. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classfp_1_1_triangulation.html#a11ee6051e9db388def8aaed68b1841d4">Triangulation::emplace_before(Index, Index, Index)</a></dd></dl>

</div>
</div>
<a id="aa9bf52cc0dc958fca2868f640cdbcb21" name="aa9bf52cc0dc958fca2868f640cdbcb21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bf52cc0dc958fca2868f640cdbcb21">&#9670;&#160;</a></span>get_distance_vector_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfp_1_1vec3.html">vec3</a>&lt; Real &gt; const  &amp; <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::get_distance_vector_to </td>
          <td>(</td>
          <td class="paramtype">Index&#160;</td>
          <td class="paramname"><em>nn_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function can provide the stored distance vector to a next neighbour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nn_id</td><td>Global id of the next neighbour <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a> which is a number between 0 and max_number_of_nodes - 1.. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the distance currently stored in the <a class="el" href="structfp_1_1_node.html#a7d7b5f362addd1bb5249f573b16d0a90" title="Distance vectors pointing from the node to it&#39;s next neighbours.">Node::nn_distances</a> vector, for the requested next neighbour. If the provided <code>nn_id</code> can not be found in the <a class="el" href="structfp_1_1_node.html#ae2e0c5a97ae4f47cff41a692ac6ce79a" title="Vector containing the global ids of current node&#39;s next neighbours.">Node::nn_ids</a> vector, then the function writes an error message to standard error output and terminates the program with exit code 12. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Calling this function with a wrong argument will cause the termination of the program.</dd></dl>

</div>
</div>
<a id="a8bc7daf80f3048d114e9adfe442c5069" name="a8bc7daf80f3048d114e9adfe442c5069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc7daf80f3048d114e9adfe442c5069">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other_node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default equality operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_node</td><td>constant reference to the other <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both nodes are equal. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac8b3254d4da11f9069ce0cbc28aa0288" name="ac8b3254d4da11f9069ce0cbc28aa0288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b3254d4da11f9069ce0cbc28aa0288">&#9670;&#160;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfp_1_1_node.html">Node</a>&lt; Real, Index &gt; const &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Streaming operator that can print formatted output to standard out with all data fields of the <a class="el" href="structfp_1_1_node.html" title="Data structure containing all geometric and topological information associated to a node.">Node</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>This is intended to be std::cout or any other ofstream reference. </td></tr>
    <tr><td class="paramname">node</td><td>The streamed node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return the updated stream. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae0618b10496535a019b5a99cdc721dca" name="ae0618b10496535a019b5a99cdc721dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0618b10496535a019b5a99cdc721dca">&#9670;&#160;</a></span>volume</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::volume</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If the node is part of a closed surface triangulation, then the <code>volume</code> contains the volume of the tetrahedron connected to each voronoi cell sub-triangle and the center of the lab coordinate system as defined in <a href="https://doi.org/10.1039/C7SM01272A">Gueguen et al. 2017</a>. </p>
<p >This means that the volume of an individual node does not have a proper physical interpretation. Only the sum of all node volumes, which is given by the triangulation is interpretable as a physical volume of an object. </p>

</div>
</div>
<a id="a65a475a50241308f3dd99313c2760f26" name="a65a475a50241308f3dd99313c2760f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a475a50241308f3dd99313c2760f26">&#9670;&#160;</a></span>unit_bending_energy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::unit_bending_energy</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>unit_bending_energy</code> corresponds to the <a href="https://en.wikipedia.org/wiki/Elasticity_of_cell_membranes">Helfrich bending energy</a> with bending rigidity 1 and gaussian bending stiffness 0. </p>
<p class="formulaDsp">
\[
 \mathrm{unit\_bending\_energy} = \frac{1}{2} A_{\mathrm{node}} (2 H_{node})^2
\]
</p>
<p> where \( H_{node} \) is the mean curvature of the node given by:  </p><p class="formulaDsp">
\[
H_{node}^2 = \frac{\vec{K}_{node}}{2A_{node}} \cdot \frac{\vec{K}_{node}}{2A_{node}}
\]
</p>
<p>, with \( \vec{K} \) denoting the Node::curvature_vector. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structfp_1_1_node.html#a2b801251ab545ad8d931d09583920537" title="Curvature vector of the node as defined in Gueguen et al. 2017.">Node::curvature_vec</a> <a class="el" href="classfp_1_1_triangulation.html#a5d5763865ac706a2e800ed306d070d68">Triangulation::update_bulk_node_geometry(Index)</a> </dd></dl>

</div>
</div>
<a id="ae2e0c5a97ae4f47cff41a692ac6ce79a" name="ae2e0c5a97ae4f47cff41a692ac6ce79a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e0c5a97ae4f47cff41a692ac6ce79a">&#9670;&#160;</a></span>nn_ids</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;floating_point_number Real, indexing_number Index&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Index&gt; <a class="el" href="structfp_1_1_node.html">fp::Node</a>&lt; Real, Index &gt;::nn_ids</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector containing the global ids of current node's next neighbours. </p>
<p ><code>nn_ids</code> contains the ids of nodes that are connected to this node in the triangulation. The next neighbours that are also mutual neighbours in the triangulation are stored sequentially in the vector. The last and the first elements are also neighbours, i.e. the nn_ids vector wraps around. During the calculation this is facilitated through the use of <a class="el" href="structfp_1_1_neighbors.html">fp::Neighbors</a>. </p><dl class="section note"><dt>Note</dt><dd>The order of the next neighbours matters for the proper function of <a class="el" href="classfp_1_1_triangulation.html">fp::Triangulation</a> but is not guaranteed by this data structure. </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>flippy/<a class="el" href="_nodes_8hpp_source.html">Nodes.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefp.html">fp</a></li><li class="navelem"><a class="el" href="structfp_1_1_node.html">Node</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
